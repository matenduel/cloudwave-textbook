---
title: "2507"
weight: 2507
draft: false
---
# Docker & Docker Compose 문제


## 1. Docker - 종합

다음 명령어에 대한 설명 중 **틀린 것**을 2개 고르시오.

```
docker run -itd --rm ubuntu bash
```

1. 명령어를 실행하면 컨테이너의 bash 프롬프트를 바로 사용할 수 있다.
2. `--rm` 옵션은 컨테이너 종료 시 자동으로 삭제되도록 한다.
3. `bash`는 Docker Image에서 정의된 CMD를 Override한다.
4. 실행된 컨테이너는 `ubuntu:latest` 이미지를 사용한다.
5. 컨테이너가 종료되어도 `docker logs`로 로그를 확인할 수 있다.



## 2. Dockerfile

`Dockerfile` 과 관련된 설명 중 옳지 않은 것은?

1. `RUN`은 이미지 빌드시에 실행된다.
2. `ADD`는 URL을 통해 원격 파일도 복사할 수 있다.
3. `ARG`는 단독으로 별도의 Layer로 제작될 수 있다.
4. `CMD`가 여러번 정의된 경우, 가장 마지막에 작성된 것이 사용된다.
5. `FROM` 보다 먼저 선언된 `ARG`는 `FROM`에서만 사용 가능하며, 이후부터는 `--build-arg`로 제공된 값과 다를 수 있다.



## 3. Dockerfile

다음 `Dockerfile`과 명령어를 이용하여 이미지를 제작하였을 때, 올바르게 설명한 것을 `2개` 고르시오.

```dockerfile
# Dockerfile
FROM nginx@sha256:bd30b8d47b230de52431cc71c5cce149b8d5d4c87c204902acf2504435d4b4c9

USER root

RUN apt-get update && apt-get -y upgrade

RUN apt-get install -y curl

RUN mkdir /code

WORKDIR /code

ADD install.sh /tmp/install.sh

WORKDIR /root

EXPOSE 80
```

```shell
# Build Command
docker build -t quiz -f Dockerfile project
```

1. 사용되는 `nginx` 이미지는 `platform`마다 달라질 수 있다.
2. `install.sh` 파일은 `/tmp` 아래에 저장된다.
3. 태그를 명시하지 않은 경우, 기본적으로 `latest`가 자동 적용되어 `quiz:latest`가 생성된다.
4. `install.sh`는 `build` 명령어를 실행한 위치(`Working Directory`)에 있는 파일이 사용된다.
5. 생성된 이미지를 이용하면 `-p` 옵션 없이도 `Host`에서 접근할 수 있다.



## 4. Dockerfile & Docker Compose

다음 `Dockerfile`을 이용하여 `quiz:4` 이미지를 생성하였다.

```dockerfile
FROM ubuntu:22.04

CMD ["echo", "3600"]

ENTRYPOINT ["echo"]
```

다음 `Yaml` 파일을 사용하여 `docker compose up`을 실행하였을 때, 출력되는 값은?

```yaml
# docker-compose.yaml
services:
  server:
	image: quiz:4
	entrypoint: "echo ep"
	command: "cm"
```

1. `3600`
2. `ep echo 3600`
3. `cm`
4. `ep cm`
5. `echo 3600`



## 5. Docker CLI

다음 명령어를 이용하여 컨테이너를 실행하였을 때, 올바르지 않은 것은?

```cmd
$ docker run -it --rm --name base -v src:/tmp ubuntu /bin/bash -c "apt-get update && apt-get -y upgrade && apt install -y curl && /bin/bash"
```

1. 이미지는 `ubuntu:latest`가 사용된다.
2. `src`이름을 가진 Docker Volume이 `/tmp`에 마운트 된다.
3. 컨테이너가 실행될 때 컨테이너의 `1번` 프로세스에서 `curl`을 설치한다.
4. `curl`이 설치된 이후에도 컨테이너는 종료되지 않는다.
5. 컨테이너가 종료된 이후에도 `docker logs`를 이용하여 로그를 확인할 수 있다.



## 6. Docker Compose CLI

다음 설명 중 옳은 것 2개를 고르시오.

1. `restart`가 `on-failure`인 경우, 정상적으로 종료되지 않은 컨테이너를 매번 재실행한다.
2. 언제나 `docker-compose.yaml`내 있는 `name`이 프로젝트 이름으로 사용된다.
3. `docker compose stop`은 컨테이너를 중지하지만 삭제하지 않는다.
4. `docker compose down`은 프로젝트 내의 항상 모든 서비스를 전부 삭제한다.
5. `docker compose up -d`는 로그를 실시간으로 출력한다.



## 7. Dockerfile - 캐시 사용

아래 `Dockerfile`에서 `index.html`만 변경하였을 때, 옳은 설명을 `2개` 고르시오.

```
FROM nginx
ENV STAGE=wave
COPY index.html /usr/share/nginx/html/index.html
RUN apt-get update && apt-get install -y curl
```

1. COPY 이전 명령까지는 모두 캐시가 사용된다.
2. `RUN` 명령은 무조건 캐시되지 않는다.
3. `COPY` 이후 `RUN`도 캐시가 무효화된다.
4. 모든 명령이 캐시된다.
5. `index.html` 변경 시 `FROM`도 다시 실행된다.



## 8. Docker Compose

다음은 `docker-compose.yaml`이다.

```yaml
# docker-compose.yaml
version: '3.8'
name: 'quiz'

services:
  postgres:
    image: postgres:16.1-bullseye
    networks:
      - db
      - private
    environment:
      - POSTGRES_PASSWORD=mysecretpassword
    volumes:
      - db_data:/var/lib/postgresql/data:rw

  server:
    image: ubuntu:22.04
    networks:
      - db

  pgadmin:
    image: dpage/pgadmin4:7.4
    environment:
      - PGADMIN_DEFAULT_EMAIL=user@sample.com
      - PGADMIN_DEFAULT_PASSWORD=SuperSecret
    networks:
      - db

volumes:
  db_data:
    name: "psql_data"
    external: true

networks:
  private:
    name: "private"
  db:
    name: "db"
    external: true
```

위의 `docker-compose.yaml`을 이용하여 다음 명령어로 프로젝트를 실행하였다. 이때, 옳지 않은 것을 2개 고르세요.

```cmd
$ docker compose -p cloudwave up -d
```

1. `server`와 `pgadmin`은 서로 통신할 수 있다.
2. `db` 네트워크는 Compose가 실행될 때 자동으로 생성된다.
3. `postgres`는 `db`, `private` 두 개의 네트워크에 연결된다.
4. `pgadmin`은 실행 후 `postgres`와 같은 네트워크에서 동작하게 된다.
5. 이 프로젝트의 이름은 `quiz`로 설정된다.



## 9. Docker Compose - 환경 변수

다음 `.env` 파일과 `docker-compose.yaml` 사용 시, 출력 결과로 올바른 것은?

```tex
# .env file
NAME=ComposeTest
```



```yaml
# docker-compose.yaml file
services:
  app:
    image: alpine
    command: ["sh", "-c", "echo $NAME"]
    env_file:
      - .env
```

1. ComposeTest
2. $NAME
3. 출력 없음
4. 에러 발생
5. alpine



## 10. Docker Compose YAML (Anchor & Alias)

다음은 `.env`파일과 `docker-compose.yaml`파일이다.

```tex
# .env file
FROM=".env.from"
BY=".env.by"
STAGE="local"
```

```tex
# prod.env file
FROM="Cloudwave"
BY="prod.env"
STAGE="prod"
```

```yaml
# docker-compose.yaml file
version: '3.8'

x-common:
  &common
  restart: always
  volumes:
    - source:/code
  environment:
    &default-env
    BY: "x-common.by"

services:
  ubuntu:
    <<: *common
    image: ubuntu:cloudwave
    build:
      dockerfile_inline: |
        FROM ubuntu:22.04
        ENV FROM=dockerfile
    environment:
      <<: *default-env
      STAGE: "yaml"
      BY: "service.by"
    env_file:
      - .env
      - prod.env
    entrypoint: /bin/bash
    command:
      - -c
      - echo "STAGE = ${STAGE} | FROM = $${FROM} | BY = $${BY}"
    restart: no
    pull_policy: build

volumes:
  source:
```

3개의 파일이 하나의 폴더에 위치하였을 때, `docker compose up`의 출력 값으로 올바른 것은?

1. `STAGE = prod | FROM = Cloudwave | BY = prod.env`
2. `STAGE = local | FROM = .env.from | BY = service.by`
3. `STAGE = prod | FROM = .env.from | BY = .env.by`
4. `STAGE = local | FROM = Cloudwave | BY = service.by`
5. `STAGE = local | FROM = dockerfile | BY = service.by`

